# Подглава 11.4 Joint-траектории и Контроллер Движения Joint-траектории\(JTAC\)

До сих пор мы контролировали сервоприводы, посылая отдельные команды положения и скорости на каждый joint в каждом цикле обновления нашего управляющего скрипта. ROS определяет более мощный метод для управления движениями нескольких joints одновременно, называемый контроллером движения joint-траектории \(`Joint Trajectory Action Controller` — JTAC\). JTAC предназначен для приема всей _joint-траектории_ в качестве входных данных.  Joint-траектория — это список или последовательность положений joint, скоростей, ускорений и усилий для каждого joint за определенный период времени.

Вы можете просмотреть компоненты положения и скорости joint-траектории, используя `rqt_plot`, чтобы отобразить соответствующие компоненты сообщения `/joint_states` во время движения руки. На рисунке ниже показано расположение шести суставов рук Pi Робота, когда он тянется к объекту. Ось `X` — это время в секундах, а ось `Y` отражает положение joint в радианах. Каждый цвет представляет разные суставы.

![](.gitbook/assets/image%20%2818%29.png)

Этот график был сгенерирован путем запуска `rqt_plot` на соответствующих позициях joints во время движения руки. Фактическая использованная команда:

```text
$ rqt_plot /joint_states/position[2], /joint_states/position[3], /joint_states/position[4], joint_states/position[5], /joint_states/position[6], /joint_states/position[8]
```

На следующем графике показаны скорости движения joints при движении руки между семью различными позами с паузой между каждым движением, кроме четвертого и пятого. Обратите внимание, как скорости joint начинаются и заканчиваются на 0 для каждой траектории, за исключением границы между четвертой и пятой траекториями, где происходит смешивание от конца одной траектории до начала следующей.

![](.gitbook/assets/image%20%2833%29.png)

Этот график был создан с помощью команды:

```text
$ rqt_plot /joint_states/velocity[2], /joint_states/velocity[3], /joint_states/velocity[4], /joint_states/velocity[5], /joint_states/velocity[6], /joint_states/velocity[8]
```

Мы можем увидеть различные поля в сообщении ROS jointtrajectory с помощью команды:

```text
$ rosmsg show jointtrajectory
```

Которая вернет следующий результат:

```text
[trajectory_msgs/jointtrajectory]:
std_msgs/header header uint32
seq
time stamp
string frame_id
string[]
joint_names
trajectory_msgs/jointtrajectorypoint[] points
float64[] positions
float64[] velocities
float64[] accelerations
float64[] effort
duration time_from_start
```

Здесь мы видим, что объединенная траектория состоит из стандартного заголовка ROS вместе с массивом имен joints и массивом точек траектории. Точка траектории состоит из множества положений, скоростей, ускорений и усилий, которые описывают движение joints в этой точке. Обратите внимание, что типичные траектории будут иметь все нули для скоростей joint для первой и последней точки, что означает, что рука начинает и заканчивает движение в состоянии покоя. Каждая точка траектории также включает в себя `time_from_start`, которое указывает количество секунд после отметки времени в заголовке, когда мы ожидаем, что траектория пройдет через эту точку.

Простейшая joint-траектория будет содержать одну точку, указывающую, как мы хотим, чтобы конфигурация joints выглядела в данный момент времени от начала. Но большинство траекторий будет включать в себя множество точек, которые описывают конфигурацию руки в различные моменты времени. Задача JTAC – интерполировать эти точки \(например, с помощью сплайнов\), чтобы создать плавную траекторию, которая может быть реализована на базовом оборудовании. Оба пакета `arbotix`и `dynamicixel_motor`предоставляют JTAC, который работает с сервоприводами Dynamixel. Таким образом, чтобы переместить multi-joint плечо Dynamixel определенным образом с течением времени, мы можем отправить желаемую joint-траекторию одному из этих контроллеров, который затем вычислит требуемую интерполяцию между точками и будет управлять сервоприводами для перемещения по запрошенной траектории. Мы увидим, как это работает позже в этой главе.       

Вам может быть интересно, как мы можем выяснить положения, скорости, ускорения и усилия каждого joint по всей траектории? И ответ в том, что мы почти никогда не должны делать это сами. Вместо этого мы обычно будем указывать гораздо более простую цель перемещения end-effector в определенную позицию и ориентацию в пространстве. Тогда мы будем полагаться на MoveIt!, чтобы вычислить общую траекторию, которая переместит end-effector в нужную позу, избегая при этом препятствий и выполняя любые другие ограничения, специфичные для задачи. Затем эта траектория будет отправлена JTAC, который даст команду сервоприводам выполнить запланированную траекторию на настоящей руке.

